#!/bin/bash
# --------------------------- start wall-clock timer --------------------------
start=$(date +%s)

# --------------- load paths generated by CMake (or prompt for them) ---------
CMAKE_PATHS_CONFIG="../build/paths.config"
if [ -f "$CMAKE_PATHS_CONFIG" ]; then
    # shellcheck disable=SC1090
    source "$CMAKE_PATHS_CONFIG"
else
    echo "paths.config not found. Starting interactive setup for paths."
    CGMF_EXECUTABLE=""
    GEANT4_BUILD_PATH=""
    ROOT_PATH=""
fi

# ----------------------- helper: validate numeric input ----------------------
validate_numeric_input() {
    local input="$1"
    if [[ "$input" =~ ^[0-9]+([.][0-9]+)?$ ]]; then
        return 0
    elif [[ "$input" == "q" || "$input" == ".q" ]]; then
        echo "Quitting…"; exit 0
    else
        echo "Error: please enter numbers only."; return 1
    fi
}

# --------------------------- ensure external paths --------------------------
prompt_for_path () {
    local varname="$1"; local prompt_msg="$2"; local test_flag="$3"
    local val="${!varname}"
    while true; do
        if [[ -n "$val" ]]; then
            if [[ "$test_flag" == "exe" && -x "$val" ]]; then break; fi
            if [[ "$test_flag" == "dir" && -d "$val" ]];  then break; fi
        fi
        echo "Error: $varname invalid or not set."
        read -rp "$prompt_msg: " val
    done
    printf -v "$varname" '%s' "$val"
    if ! grep -q "^${varname}=" "$CMAKE_PATHS_CONFIG" 2>/dev/null; then
        echo "${varname}=\"${val}\"" >> "$CMAKE_PATHS_CONFIG"
    fi
}

prompt_for_path CGMF_EXECUTABLE    "Enter the path to cgmf.x"        exe
prompt_for_path GEANT4_BUILD_PATH  "Enter the Geant4 build path"    dir
prompt_for_path ROOT_PATH          "Enter the ROOT installation"    dir

export PATH="$ROOT_PATH/bin:$GEANT4_BUILD_PATH/bin:$PATH"
export LD_LIBRARY_PATH="$ROOT_PATH/lib:$GEANT4_BUILD_PATH/lib:$LD_LIBRARY_PATH"

# -------------------- ensure helper executables exist ---------------------
declare -A EXECUTABLES=(
  [cgmfToCsv]=cgmfToCsv
  [randtimes1]=randtimes1
)

pushd "../src" >/dev/null
for exe in "${!EXECUTABLES[@]}"; do
  if [[ -x "${EXECUTABLES[$exe]}" ]]; then
    echo "$exe found."
  else
    echo "$exe not found – compiling…"
    make --no-print-directory "$exe" \
      || { echo "Compilation of $exe failed."; exit 1; }
  fi
done
popd >/dev/null


# --------------------- compile ROOT tool ---------------------
if [[ -x "./shiftTimes" ]]; then
  echo "shiftTimes found."
else
  echo "shiftTimes not found – compiling shiftTimes.cpp…"
  g++ shiftTimes.cpp $(root-config --cflags --libs) -o shiftTimes \
    || { echo "Compilation of shiftTimes failed."; exit 1; }
fi

# -------------------------- CLI arg parsing ----------------------------------
usage(){
  cat <<EOF
Usage: $0 MODE [ARGS]

Modes:
  -ci                 cgmf interactive (runs a new CGMF job)
  -cf <file.cgmf.0>   cgmf file       (convert existing .cgmf.0 to CSV + continue)
  -csv <file.csv>     csv file        (use existing CSV + continue)
  -rt <file.root>     root output     (shift times in existing ROOT file)
EOF
  exit 1
}
[[ $# -lt 1 ]] && usage
while [[ $# -gt 0 ]]; do
  case "$1" in
    -ci)  MODE="cgmf_interactive"; shift ;;
    -cf)  [[ -n "$2" && "${2:0:1}" != "-" ]] || { echo "Error: -cf needs .cgmf.0"; usage; }
          MODE="cgmf_file"; CGMF_OUTPUT_FILE="$2"; shift 2 ;;
    -csv) [[ -n "$2" && "${2:0:1}" != "-" ]] || { echo "Error: -csv needs .csv"; usage; }
          MODE="csv_file"; EXISTING_CSV_FILE="$2"; shift 2 ;;
    -rt)  [[ -n "$2" && "${2:0:1}" != "-" ]] || { echo "Error: -rt needs .root"; usage; }
          MODE="root_output"; ROOT_INPUT_FILE="$2"; shift 2 ;;
    *)    usage ;;
  esac
done

# ---------------------- common user prompts ------------------------
# --- isotope & fission/activity/rate ---
while true; do
  read -rp "Enter the isotope (e.g., 92235 or 98252): " ISOTOPE
  validate_numeric_input "$ISOTOPE" && break
done
export ISOTOPE

if [[ "$ISOTOPE" == "98252" ]]; then
  prompt_msg="Enter desired activity (/s):"
else
  prompt_msg="Enter desired fission rate (fissions/s):"
fi
while true; do
  read -rp "$prompt_msg " FISSION_RATE
  validate_numeric_input "$FISSION_RATE" && break
done
export MY_FISSION_RATE="$FISSION_RATE"

# --- number of events ---
while true; do
  read -rp "Enter the number of events: " NUM_EVENTS
  validate_numeric_input "$NUM_EVENTS" && break
done
export MY_FISSION_COUNT="$NUM_EVENTS"

# --- neutrons flag for CGMF steps only ---
if [[ "$MODE" == "cgmf_interactive" || "$MODE" == "cgmf_file" ]]; then
  while true; do
    read -rp "Include neutrons in the CSV? (y/n): " yn
    case "$yn" in
      [Yy]*) NEUTRON_FLAG=""; break ;;
      [Nn]*) NEUTRON_FLAG="--no-neutrons"; break ;;
      *)     echo "Please answer y or n." ;;
    esac
  done
  export NEUTRON_FLAG
fi

# ————————————— source‐geometry selection & patching —————————————
PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
TG_DIR="$PROJECT_ROOT"
MASTER_TG=""   # will be set below
CylName=""     # name of the solid in the .tg file
RADIUS_OVERRIDE=""
THICK_OVERRIDE=""

# default: no source → DetCon.tg
USE_SRC_GEOM=0
if [[ "$ISOTOPE" == "98252" || "$ISOTOPE" == "92235" ]]; then
  while true; do
    read -rp "Switch to source geometry for $ISOTOPE? (y/n): " yn
    case "$yn" in
      [Yy]*) USE_SRC_GEOM=1; break ;;
      [Nn]*) USE_SRC_GEOM=0; break ;;
      *)     echo "Please answer y or n." ;;
    esac
  done
fi

if [[ "$USE_SRC_GEOM" -eq 1 ]]; then

  # pick the correct template and cylinder name
  if [[ "$ISOTOPE" == "98252" ]]; then
    MASTER_TG="$TG_DIR/252CfDetCon.tg"
    CylName="CfCylinder"
    DEFAULT_RADIUS="0.025"
  else
    MASTER_TG="$TG_DIR/235UDetCon.tg"
    CylName="UFCylinder"
    DEFAULT_RADIUS="0.5"
  fi

  [[ -s "$MASTER_TG" ]] || { echo "ERROR: $MASTER_TG missing"; exit 1; }

  # 1) radius override?
  read -rp "Override source radius? (y/n): " yn
  if [[ "$yn" =~ ^[Yy] ]]; then
    while true; do
      read -rp "Enter new radius in cm: " RADIUS_OVERRIDE
      validate_numeric_input "$RADIUS_OVERRIDE" && break
    done
  fi

  # 2) thickness override?
  if [[ "$ISOTOPE" == "98252" ]]; then
    # Cf-252: offer activity‐based first
    read -rp "Recalculate thickness from activity? (y/n): " yn
    if [[ "$yn" =~ ^[Yy] ]]; then
      THICK_OVERRIDE=$(awk -v R="$FISSION_RATE" -v r="${RADIUS_OVERRIDE:-$DEFAULT_RADIUS}" 'BEGIN{
        CfDecay=2.56e-10; aCf=2.39e21; aC=5.016e22; aH2O=3.34e22;
        pi=3.141592653589793;
        Ncf=R/CfDecay; NC=Ncf*500; NH=Ncf*200;
        gCf=Ncf/aCf; gC=NC/aC; gH=NH/aH2O;
        t=(gCf+gC+gH)/(pi*r*r);
        printf("%.10g",t/2);
      }')
    else
      read -rp "Manually override thickness? (y/n): " yn2
      if [[ "$yn2" =~ ^[Yy] ]]; then
        while true; do
          read -rp "Enter full thickness in cm: " TIN
          validate_numeric_input "$TIN" && break
        done
        THICK_OVERRIDE=$(awk -v t="$TIN" 'BEGIN{printf("%.10g",t/2)}')
      fi
    fi
  else
    # U-235: only manual override
    read -rp "Manually override sample thickness? (y/n): " yn
    if [[ "$yn" =~ ^[Yy] ]]; then
      while true; do
        read -rp "Enter full thickness in cm: " TIN
        validate_numeric_input "$TIN" && break
      done
      THICK_OVERRIDE=$(awk -v t="$TIN" 'BEGIN{printf("%.10g",t/2)}')
    fi
  fi

  # 3) apply any overrides
  if [[ -n "$RADIUS_OVERRIDE" ]]; then
    sed -i -E \
      "s|^(:solid[[:space:]]+${CylName}[[:space:]]+TUBE[[:space:]]+0\*cm)[^*]+(\*cm)|\1 ${RADIUS_OVERRIDE}*cm\2|" \
      "$MASTER_TG"
  fi

  if [[ -n "$THICK_OVERRIDE" ]]; then
    sed -i -E \
      "s|^(:solid[[:space:]]+${CylName}[[:space:]]+TUBE[[:space:]]+0\*cm[[:space:]]+[^*]+\*cm[[:space:]]+)[^*]+(\*cm)|\1 ${THICK_OVERRIDE}*cm\2|" \
      "$MASTER_TG"
  fi

else
  MASTER_TG="$TG_DIR/DetCon.tg"
  [[ -s "$MASTER_TG" ]] || { echo "ERROR: $MASTER_TG missing"; exit 1; }
fi

export G4_TG_FILE="$MASTER_TG"


# --------------------- mode‐specific processing -----------------------------
if [[ "$MODE" == "cgmf_interactive" ]]; then

    while true; do
        read -rp "Enter neutron energy in MeV (0 for spontaneous): " ENERGY
        validate_numeric_input "$ENERGY" && break
    done
    read -rp "Desired base name for output files: " OUTPUT_NAME
    [[ "$OUTPUT_NAME" =~ ^(q|\.q)$ ]] && { echo "Quitting…"; exit 0; }
    OUTPUT_FILE="${OUTPUT_NAME}.cgmf"
    ROOT_OUTPUT_FILE="${OUTPUT_NAME}.root"
    RANDOM_SEED=$RANDOM

    stdbuf -o0 "$CGMF_EXECUTABLE" \
      -i "$ISOTOPE" -e "$ENERGY" \
      -n "$NUM_EVENTS" -s "$RANDOM_SEED" -f "$OUTPUT_FILE" \
      || { echo "CGMF failed."; exit 1; }
    ACTUAL_OUTPUT_FILE="${OUTPUT_FILE}.0"
    [[ -s "$ACTUAL_OUTPUT_FILE" ]] || { echo "Missing CGMF output."; exit 1; }
    CSV_OUTPUT_FILE="${OUTPUT_NAME}.csv"

    ./cgmfToCsv "$ACTUAL_OUTPUT_FILE" "$CSV_OUTPUT_FILE" "massExcess.csv" \
      $NEUTRON_FLAG \
      || { echo "cgmfToCsv failed."; exit 1; }


    CSV_FULL_PATH="$(pwd)/${CSV_OUTPUT_FILE}"
    echo "CSV written to $CSV_FULL_PATH"

elif [[ "$MODE" == "csv_file" ]]; then

    [[ -f "$EXISTING_CSV_FILE" ]] || { echo "CSV not found."; exit 1; }
    CSV_FULL_PATH="$(realpath "$EXISTING_CSV_FILE")"
    OUTPUT_NAME=$(basename "$EXISTING_CSV_FILE" .csv)
    ROOT_OUTPUT_FILE="${OUTPUT_NAME}.root"



elif [[ "$MODE" == "root_output" ]]; then

    [[ -f "$ROOT_INPUT_FILE" ]] || { echo "ROOT missing."; exit 1; }

    read -rp "TTree name (no ;#): " TREE_NAME
    [[ -n "$TREE_NAME" ]] || { echo "No tree name"; exit 1; }
    read -rp "Time branch: " TIME_BRANCH
    [[ -n "$TIME_BRANCH" ]] || { echo "No time branch"; exit 1; }
    read -rp "Event-ID branch: " EVENT_BRANCH
    [[ -n "$EVENT_BRANCH" ]] || { echo "No event branch"; exit 1; }

    TIME_SHIFTS_FILE="time_shifts.txt"
    ./randtimes1 "$NUM_EVENTS" "$FISSION_RATE" > "$TIME_SHIFTS_FILE"
    [[ $? -eq 0 && -s "$TIME_SHIFTS_FILE" ]] \
      || { echo "randtimes1 failed"; exit 1; }

    INPUT_DIR="$(dirname "$ROOT_INPUT_FILE")"
    BASENAME="$(basename "$ROOT_INPUT_FILE" .root)"
    ROOT_OUTPUT_FILE="${INPUT_DIR}/${BASENAME}_shifted.root"

    echo "Invoking shiftTimes…"
    ./shiftTimes \
      "$ROOT_INPUT_FILE" \
      "$ROOT_OUTPUT_FILE" \
      "$TIME_SHIFTS_FILE" \
      "$TREE_NAME" \
      "$TIME_BRANCH" \
      "$EVENT_BRANCH"
    [[ $? -eq 0 && -f "$ROOT_OUTPUT_FILE" ]] \
      || { echo "shiftTimes failed or no output"; exit 1; }

    echo "Shifted file → $ROOT_OUTPUT_FILE"
    exit 0

elif [[ "$MODE" == "cgmf_file" ]]; then

    # ensure the .cgmf.0 exists
    [[ -f "$CGMF_OUTPUT_FILE" ]] || { echo "Error: CGMF .0 missing: $CGMF_OUTPUT_FILE"; exit 1; }

    # derive base name and CSV name
    OUTPUT_NAME=$(basename "$CGMF_OUTPUT_FILE" .cgmf.0)
    CSV_OUTPUT_FILE="${OUTPUT_NAME}.csv"

    # convert CGMF output to CSV, passing the neutron flag
    ./cgmfToCsv "$CGMF_OUTPUT_FILE" "$CSV_OUTPUT_FILE" "massExcess.csv" \
      $NEUTRON_FLAG \
      || { echo "cgmfToCsv failed."; exit 1; }

    # set up for the sim
    CSV_FULL_PATH="$(pwd)/${CSV_OUTPUT_FILE}"
    echo "CSV written to $CSV_FULL_PATH"

    # point the ROOT output to match the CSV base name
    ROOT_OUTPUT_FILE="${OUTPUT_NAME}.root"
else
    echo "Internal error: unknown MODE=$MODE"
    exit 1
fi

# -------------------- generate random time shifts ----------
TIME_SHIFTS_FILE="time_shifts.txt"
./randtimes1 "$NUM_EVENTS" "$FISSION_RATE" > "$TIME_SHIFTS_FILE"
[[ -s "$TIME_SHIFTS_FILE" ]] || { echo "time_shifts.txt empty."; exit 1; }

# ------------- patch MyRunAction.cc to update ROOT file name ----------------
MY_RUN_ACTION_PATH="../src/MyRunAction.cc"
sed -i "s|analysisManager->OpenFile(\".*\");|analysisManager->OpenFile(\"$ROOT_OUTPUT_FILE\");|" \
  "$MY_RUN_ACTION_PATH" || { echo "Failed to patch MyRunAction.cc"; exit 1; }

# ----------------------------- build & run Geant4 ---------------------------
make -C "$GEANT4_BUILD_PATH" || { echo "make failed."; exit 1; }
cd "$GEANT4_BUILD_PATH" || exit 1
./sim "$CSV_FULL_PATH" 2>&1 | tee geant4_sim_output.log
[[ ${PIPESTATUS[0]} -ne 0 ]] && { echo "Geant4 failed."; exit 1; }

# ----------------------------- timing stats ---------------------------------
end=$(date +%s)
echo "Total run time: $(( end - start )) seconds."
exit 0

