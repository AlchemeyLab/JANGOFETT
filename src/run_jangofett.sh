#!/bin/bash

# Define the path to paths.config generated by CMake
CMAKE_PATHS_CONFIG="../build/paths.config"

# Load paths from the configuration file, or prompt for paths if not found
if [ -f "$CMAKE_PATHS_CONFIG" ]; then
    source "$CMAKE_PATHS_CONFIG"
    echo "Using paths from $CMAKE_PATHS_CONFIG"
else
    echo "paths.config not found. Starting interactive setup for paths."
    CGMF_CUSTOM_PATH=""
    GEANT4_CUSTOM_PATH=""
    ROOT_CUSTOM_PATH=""
fi

# Function to validate paths
validate_path() {
    local path="$1"
    if [[ -z "$path" || ! -e "$path" ]]; then
        return 1 
    fi
    return 0
}

# Prompt for CGMF path if missing or incorrect
if [ -z "$CGMF_EXECUTABLE" ] || [ ! -x "${CGMF_EXECUTABLE}" ]; then
    echo "Error: CGMF executable not found or not executable."
    while true; do
        read -p "Enter the path to the CGMF executable (e.g., /path/to/cgmf.x): " CGMF_EXECUTABLE
        if [ -x "$CGMF_EXECUTABLE" ]; then
            echo "CGMF path set to: $CGMF_EXECUTABLE"
            break
        else
            echo "Error: cgmf.x not found or not executable at the specified path."
        fi
    done
    echo "CGMF_EXECUTABLE=\"$CGMF_EXECUTABLE\"" >> "$CMAKE_PATHS_CONFIG"
fi

# Prompt for Geant4 path if missing or incorrect
if [ -z "$GEANT4_BUILD_PATH" ] || [ ! -d "$GEANT4_BUILD_PATH" ]; then
    echo "Error: Geant4 build directory not found."
    while true; do
        read -p "Enter the path to the Geant4 build directory (e.g., /path/to/geant4-build): " GEANT4_BUILD_PATH
        if [ -d "$GEANT4_BUILD_PATH" ]; then
            echo "Geant4 path set to: $GEANT4_BUILD_PATH"
            break
        else
            echo "Error: Invalid Geant4 directory."
        fi
    done
    echo "GEANT4_BUILD_PATH=\"$GEANT4_BUILD_PATH\"" >> "$CMAKE_PATHS_CONFIG"
fi

# Prompt for ROOT path if missing or incorrect
if [ -z "$ROOT_PATH" ] || [ ! -f "${ROOT_PATH}/bin/root-config" ]; then
    echo "Error: ROOT installation not found."
    while true; do
        read -p "Enter the path to the ROOT installation (e.g., /path/to/root): " ROOT_PATH
        if [ -f "${ROOT_PATH}/bin/root-config" ]; then
            echo "ROOT path set to: $ROOT_PATH"
            break
        else
            echo "Error: ROOT not found in the specified directory."
        fi
    done
    echo "ROOT_PATH=\"$ROOT_PATH\"" >> "$CMAKE_PATHS_CONFIG"
fi

# Ensure paths.config is updated and sourced
source "$CMAKE_PATHS_CONFIG"

# Export paths
export PATH="$ROOT_PATH/bin:$GEANT4_BUILD_PATH/bin:$PATH"
export LD_LIBRARY_PATH="$ROOT_PATH/lib:$GEANT4_BUILD_PATH/lib:$LD_LIBRARY_PATH"

echo "Paths successfully configured."

# Define required executables and their source directories
declare -A EXECUTABLES
EXECUTABLES["cgmfToCsv"]="../src/cgmfToCsv"
EXECUTABLES["randtimes1"]="../src/randtimes1"

# Function to check if an executable exists and compile if necessary
check_and_compile() {
    local exe_name="$1"
    local exe_path="${EXECUTABLES[$exe_name]}"

    if [ ! -x "$exe_path" ]; then
        echo "Executable $exe_name not found or not executable. Attempting to compile..."
        
        # Identify the source directory
        local src_dir
        if [[ "$exe_name" == "sim" ]]; then
            src_dir="$GEANT4_BUILD_PATH"
        else
            src_dir="../src"
        fi

        # Compile the executable
        make -C "$src_dir" "$exe_name"
        
        # Check if compilation was successful
        if [ ! -x "$exe_path" ]; then
            echo "Error: Compilation of $exe_name failed. Exiting."
            exit 1
        fi
        echo "$exe_name compiled successfully."
    else
        echo "Executable $exe_name found."
    fi
}

# Ensure required executables exist
for exe in "${!EXECUTABLES[@]}"; do
    check_and_compile "$exe"
done


# Function to validate numeric input or quit command
validate_numeric_input() {
    local input="$1"
    if [[ "$input" == "q" || "$input" == ".q" ]]; then
        echo "Quitting..."
        exit 0
    elif [[ ! "$input" =~ ^[0-9]+([.][0-9]+)?$ ]]; then
        echo "Error: Please enter only numbers."
        return 1
    else
        return 0
    fi
}

# Function to display usage information
usage() {
    echo "Usage: $0 -i for interactive mode or -f <cgmf_file> to load an existing .cgmf.0 file"
    exit 1
}


# Parse command-line arguments
while getopts "if:" opt; do
    case ${opt} in
        i )
            MODE="interactive"
            ;;
        f )
            MODE="file"
            EXISTING_CGMF_FILE="$OPTARG"
            ;;
        \? )
            usage
            ;;
    esac
done

# Ensure either interactive or file mode is selected
if [ -z "$MODE" ]; then
    usage
fi

# Prompt for the fission rate
while true; do
    read -p "Enter the desired fission rate (fissions per second): " FISSION_RATE
    validate_numeric_input "$FISSION_RATE" && break
done

export MY_FISSION_RATE="$FISSION_RATE"

# Prompt for the number of events
while true; do
    read -p "Enter the number of events: " NUM_EVENTS
    validate_numeric_input "$NUM_EVENTS" && break
done

export MY_FISSION_COUNT="$NUM_EVENTS"

if [ "$MODE" = "interactive" ]; then
    while true; do
        read -p "Enter the isotope (e.g., 92235 for U-235): " ISOTOPE
        validate_numeric_input "$ISOTOPE" && break
    done

    while true; do
        read -p "Enter the neutron energy in MeV (or 0 for spontaneous fission): " ENERGY
        validate_numeric_input "$ENERGY" && break
    done

    read -p "Enter the desired name for the output file (without extension): " OUTPUT_NAME
    if [[ "$OUTPUT_NAME" == "q" || "$OUTPUT_NAME" == ".q" ]]; then
        echo "Quitting..."
        exit 0
    fi
    OUTPUT_FILE="${OUTPUT_NAME}.cgmf"
    ROOT_OUTPUT_FILE="${OUTPUT_NAME}.root"
    RANDOM_SEED=$RANDOM

    # Run CGMF
    stdbuf -o0 "$CGMF_EXECUTABLE" -i "$ISOTOPE" -e "$ENERGY" -n "$NUM_EVENTS" -s "$RANDOM_SEED" -f "$OUTPUT_FILE"

    # Check if CGMF execution was successful
    if [ $? -ne 0 ]; then
        echo "Error: CGMF failed to execute. Exiting."
        exit 1
    fi

    # Check if the CGMF output file exists and is not empty
    ACTUAL_OUTPUT_FILE="${OUTPUT_FILE}.0"
    if [ ! -s "$ACTUAL_OUTPUT_FILE" ]; then
        echo "Error: CGMF output file '$ACTUAL_OUTPUT_FILE' is missing or empty. Exiting."
        exit 1
    fi
else
    ACTUAL_OUTPUT_FILE="$EXISTING_CGMF_FILE"
    OUTPUT_NAME=$(basename "$EXISTING_CGMF_FILE" .cgmf.0)
    ROOT_OUTPUT_FILE="${OUTPUT_NAME}.root"
fi

# Verify CGMF output file exists
if [ ! -f "$ACTUAL_OUTPUT_FILE" ]; then
    echo "Error: Could not find the CGMF output file: $ACTUAL_OUTPUT_FILE"
    exit 1
fi

# Convert CGMF output to CSV
CSV_OUTPUT_FILE="${OUTPUT_NAME}.csv"
if ! "./cgmfToCsv" "$ACTUAL_OUTPUT_FILE" "$CSV_OUTPUT_FILE" "massExcess.csv"; then
    echo "Error: cgmfToCsv conversion failed. Exiting."
    exit 1
fi

# Generate time shifts using randtimes1
TIME_SHIFTS_FILE="time_shifts.txt"

echo "Running randtimes1 with redirection:"
./randtimes1 "$NUM_EVENTS" "$FISSION_RATE" > "$TIME_SHIFTS_FILE"

echo "Checking contents of time_shifts.txt:"
#cat "$TIME_SHIFTS_FILE"
ls -l "$TIME_SHIFTS_FILE"

# Verify time shifts file exists
if [ ! -s "$TIME_SHIFTS_FILE" ]; then
    echo "Error: time_shifts.txt is empty or missing. Exiting."
    exit 1
fi

# Modify MyRunAction.cc to set the correct ROOT output file name
MY_RUN_ACTION_PATH="../src/MyRunAction.cc"
if [ -f "$MY_RUN_ACTION_PATH" ]; then
    sed -i "s|analysisManager->OpenFile(\".*\");|analysisManager->OpenFile(\"$ROOT_OUTPUT_FILE\");|" "$MY_RUN_ACTION_PATH"
    echo "Modified MyRunAction.cc to change the ROOT output filename to $ROOT_OUTPUT_FILE"

    # Recompile the Geant4 project
    echo "Recompiling Geant4 project..."
    make -C "$GEANT4_BUILD_PATH"
    if [ $? -ne 0 ]; then
        echo "Error: Geant4 project recompilation failed. Exiting."
        exit 1
    fi
else
    echo "Error: MyRunAction.cc not found at $MY_RUN_ACTION_PATH"
    exit 1
fi

# Run Geant4 simulation and pass time shifts
export TIME_SHIFTS_FILE
cd "$GEANT4_BUILD_PATH" || exit 1
if ! ./sim "$(realpath "../src/$CSV_OUTPUT_FILE")" 2>&1 | tee geant4_sim_output.log; then
    echo "Error: Geant4 simulation failed. Exiting."
    exit 1
fi

exit 0

